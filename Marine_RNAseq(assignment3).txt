Gene Expression Analysis
¶
Tutorial Outline¶
1. Introduction
2. Accessing the Data using SRA-Toolkit
3. Quality control using scythe/sickle
4. Aligning Reads to a Genome using hisat2
1. Building an Index
2. Aligning the reads using HISAT2
5. Generating Total Read Counts from Alignment using htseq-count
1. Assignemnt 3 Activity 1
6. Differential expression with counts and edgeR
1. Using EdgeR
2. Normalization
3. Comparision between groups
4. Common plots for differential expression analysis
7. Integrating the DE Results with the Annotation Results
8. Assignment 3 Activity 2

1. Introduction
This exercise will guide you through the RNAseq analysis using Illumina sequence data and identify genes
that display differences in expression between experimental treatments (i.e. Differentially expressed
genes. Below is the overview of the steps that we need to complete inorder to obtain a list of differentially
expressed genes.

Liver mRNA profiles from large yellow croaker (Larimichthys crocea) species are sampled during various
conditions namely, control group (LB2A), thermal stress group (LC2A), cold stress group (LA2A) and 21-day
fasting group (LF1A) were generated by RNA-seq, using Illumina HiSeq 2000. Below is a picture of

Larimichthys crocea to give you an idea of the organism that we will be working with throughout the
exercise.

2. Accessing the Data using SRAToolkit
We will be downloading our data from the sequence-read-archives (SRA), a comprehensive collection of
sequenced genetic data submitted to the NCBI by experimenters. The beauty of the SRA is the ease with
which genetic data becomes accessible to any scientist with an internet connection, available for download
in a variety of formats. Each run in the SRA has a unique identifier. The run may be downloaded using a
module of software called the "sratoolkit" and its unique identifier. There are a variety of commands in the
sratoolkit, which I invite you to investigate for yourself at https://www.ncbi.nlm.nih.gov/books/NBK158900/.
The data may be accessed at the following web page: https://trace.ncbi.nlm.nih.gov/Traces/sra/?
study=SRP057063

LF1A : SRR1964648, SRR1964649
LA2A : SRR1964646, SRR1964647
LB2A : SRR1964642, SRR1964643
LC2A : SRR1964644, SRR1964645
We can download the SRA data using a parallel version SRA-Toolkit that allows for multiple threads (CPU)
using the following bash code but this step has already been completed using liver_dump.sh because of
time constraints:

#!/bin/bash
SRA="SRR1964648
SRR1964649
SRR1964646
SRR1964647
SRR1964642
SRR1964643
SRR1964644
SRR1964645"
for i in $SRA
do
parallel-fastq-dump --sra-id $i --threads 4 --outdir /home/WWU/BIOL497R/data/RNAseq/ -split-files --gzip
done
Data is located in:

/home/WWU/BIOL497R/data/RNAseq/

Lets have a look at athe contents of one of the fastq-files:
In [ ]:

%%bash
head -n 8 /home/WWU/BIOL497R/data/RNAseq/SRR1964648_1.fastq
In [ ]:

3. Quality control using scythe/sickle
In this section, we will do the quality control processing of the RNAseq libraries. This incorperates content
that we learned in Ex3_read_processing.
Briefly, scythe removes adapter contamination from the Illumina sequencing technology and sickle
performs the quality trimming. Below are the usage examples for each program.
Scythe:

Usage: scythe -a adapter_file.fasta sequence_file.fastq
Trim 3'-end adapter contaminants off sequence files. If no output file
is specified, scythe will use stdout.
Options:
-p, --prior

prior (default: 0.300)

-q, --quality-type

quality type, either illumina, solexa, or sanger (default:

sanger)
-m, --matches-file

matches file (default: no output)

-o, --output-file output trimmed sequences file (default: stdout)
-t, --tag

add a tag to the header indicating Scythe cut a sequence (default: off)

-n, --min-match

smallest contaminant to consider (default: 5)

-M, --min-keep

filter sequnces less than or equal to this length (default: 35)

--quiet

don't output statistics about trimming to stdout (default: off)

--help

display this help and exit

--version

output version information and exit

Sickle and since we have single end sequences, typing sickle se will give the single-end-read options:

Usage: sickle se [options] -f

-t

-o

Options:
-f, --fastq-file, Input fastq file (required)
-t, --qual-type, Type of quality values (solexa (CASAVA < 1.3), illumina (CASAVA 1.3 to
1.7), sanger (which is CASAVA >= 1.8)) (required)
-o, --output-file, Output trimmed fastq file (required)

-q, --qual-threshold, Threshold for trimming based on average quality in a window.
Default 20.
-l, --length-threshold, Threshold to keep a read based on length after trimming.
Default 20.
-x, --no-fiveprime, Don't do five prime trimming.
-n, --trunc-n, Truncate sequences at position of first N.
-g, --gzip-output, Output gzipped files.
--quiet, Don't print out any trimming

Information

--help, display this help and exit
--version, output version

Information and exit

The quality may be any score from 0 to 40. The default of 20 is much too low for a robust analysis. We
want to select only reads with a quality of 30 or better. Additionally, the Illumina sequencing technology
used in this experiment generated read lengths of 50bp. Again, we see that a default of 20 is much too low
for analysis confidence. We want to select only reads whose lengths exceed 36bp. Lastly, we must know
the scoring type. While the quality type is not listed on the SRA pages, most SRA reads use the "sanger"
quality type. Unless explicitly stated, try running sickle using the sanger qualities. If an error is returned,
try illumina. If another error is returned, lastly try solexa.
Let's put all of this together for our scythe/sickle processing using our downloaded fastq files:

DATA="/home/WWU/BIOL497R/data/RNAseq"
ADAPTERS="/home/WWU/BIOL497R/notebooks/Ex3_read_processing/adapters.fa"
SRA="SRR1964648_1
SRR1964649_1
SRR1964646_1
SRR1964647_1
SRR1964642_1
SRR1964643_1
SRR1964644_1
SRR1964645_1"
for i in $SRA
do
#save stdout messages to .out for each library
scythe -a $ADAPTERS --quiet -o $DATA/quality_control/$i.scythe.fastq $DATA/$i.fastq 1
&> quality_control/$i.out
sickle se -f $DATA/quality_control/$i.scythe.fastq -t sanger -q 30 -l 36 -o
$DATA/quality_control/$i.scythe.sickle.fastq >> quality_control/$i.out
done
Following the scythe/sickle run the results can be found in the $DATA/quality_control folder. Examine

the .out files generated during the run. It will provide a summary of the quality control process. The
resulting file structure will look as follows:

$DATA/quality_control/
├── SRR1964642_1.out
├── SRR1964642_1.scythe.fastq
├── SRR1964642_1.scythe.sickle.fastq
.
.
.
├── SRR1964649_1.out
├── SRR1964649_1.scythe.fastq
└── SRR1964649_1.scythe.sickle.fastq
Lastly, we can conduct a before and after QC analysis using fastQC.

DATA="/home/WWU/BIOL497R/data/RNAseq"
SRA="SRR1964648_1
SRR1964649_1
SRR1964646_1
SRR1964647_1
SRR1964642_1
SRR1964643_1
SRR1964644_1
SRR1964645_1"
for i in $SRA
do
#before
fastqc --outdir $DATA/before $DATA/$i.fastq -t 4
#after
fastqc --outdir $DATA/after $DATA/quality_control/$i.scythe.sickle.fastq -t 4
done
This will produce the html files with the quality reports and the file strucutre in side the folder fastqc will
look like:

$DATA/fastqc/
├── after
│

├── SRR1964642_1.scythe.sickle_fastqc.html

│

├── SRR1964642_1.scythe.sickle_fastqc.zip

│

├── ...

│

├── ...

│

├── SRR1964649_1.scythe.sickle_fastqc.html

│

└── SRR1964649_1.scythe.sickle_fastqc.zip

├── before
│

├── SRR1964642_1_fastqc.html

│

├── SRR1964642_1_fastqc.zip

│

├── ...

│

├── ...

│

├── SRR1964649_1_fastqc.html

│

└── SRR1964649_1_fastqc.zip

4. Aligning Reads to a Genome using
hisat2
A. Building an Index:
HISAT2 is a fast and sensitive aligner for mapping next generation sequencing reads against a reference
genome. In order to map the reads to a reference genome, first we must download the reference genome!
Then we must make an index file. We will be downloading the reference genome
(https://www.ncbi.nlm.nih.gov/genome/12197) from the ncbi database, using the wget command and
rename the files to L_crocea.
In [ ]:

%%bash
wget -q
ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/972/845/GCF_000972845.1_L_crocea_1.0/
GCF_000972845.1_L_crocea_1.0_genomic.fna.gz -O L_crocea.fna.gz
gunzip L_crocea.fna.gz
wget -q
ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/972/845/GCF_000972845.1_L_crocea_1.0/
GCF_000972845.1_L_crocea_1.0_genomic.gff.gz -O L_crocea.gff.gz
gunzip L_crocea.gff.gz
We will use the hisat2-build option to make a HISAT index file for the genome. It will create a set of files
with the suffix .ht2, these files together build the index. What is an index and why is it helpful? Genome
indexing is the same as indexing a tome, like an encyclopedia. It is much easier to locate information in
the vastness of an encyclopedia when you consult the index, which is ordered in an easily navigatable way
with pointers to the location of the information you seek within the encylopedia. Genome indexing is thus
the structuring of a genome such that it is ordered in an easily navigatable way with pointers to where we
can find whichever gene is being aligned. The genome index along with the quality trimmed fasta files are

all you need to align the reads to the reference genome.

HISAT2 version 2.1.0 by Daehwan Kim (infphilo@gmail.com, http://www.ccb.jhu.edu/people/
infphilo)
Usage: hisat2-build [options]* <reference_in> <ht2_index_base>
reference_in

comma-separated list of files with ref sequences

hisat2_index_base

write ht2 data to files with this dir/basename

Options:
-c

reference sequences given on cmd line (as
<reference_in>)

--large-index

force generated index to be 'large', even if ref
has fewer than 4 billion nucleotides

-a/--noauto

disable automatic -p/--bmax/--dcv memory-fitting

-p

number of threads

In [ ]:

%%bash
hisat2-build -p 4 L_crocea.fna

L_crocea

After running the command, the following files will be generated as part of the index. To refer to the index
for mapping the reads in the next step, you will use the file prefix, which in this case is: L_crocea

RNAseq/
├── L_crocea.gff
├── L_crocea.fna
├── L_crocea.1.ht2
├── L_crocea.2.ht2
├── L_crocea.3.ht2
├── L_crocea.4.ht2
├── L_crocea.5.ht2
├── L_crocea.6.ht2
├── L_crocea.7.ht2
└── L_crocea.8.ht2

B. Aligning the reads using HISAT2:
Once we have created the index, the next step is to align the reads with HISAT2 using the index we
created. The program will give the output in SAM format. We will not delve into the intricacies of the SAM
format here, but it is recommended to peruse https://en.wikipedia.org/wiki/SAM_(file_format) again to
garner a greater understanding. We align our reads with the following code.
Usage:

Usage: hisat2 [options]* -x <ht2-idx>
-x <ht2-idx>

[-S <sam>]

path to the Index-filename-prefix (minus trailing .X.ht2)

Options:
-q

query input files are FASTQ .fq/.fastq (default)

-p

number threads

--dta

reports alignments tailored for transcript assemblers

Command for aligning the reads using hisat:
In [ ]:

%%bash
DATA="/home/WWU/BIOL497R/data/RNAseq"
mkdir sam
hisat2 -p 4 --dta -x L_crocea -q $DATA/quality_control/SRR1964648_1.scythe.sickle.fastq
-S sam/SRR1964648.sam
When HISAT2 completes its run, it will summarize each of it’s alignments, and it is printed to the window
as standard error message. Below is what one of those meassages look like:

25754901 reads; of these:
25754901 (100.00%) were unpaired; of these:
1793224 (6.96%) aligned 0 times
21247602 (82.50%) aligned exactly 1 time
2714075 (10.54%) aligned >1 times
93.04% overall alignment rate
Let's have a look at the SAM file:

@HD VN:1.0 SO:unsorted
@SQ SN:NW_017607850.1 LN:6737
@SQ SN:NW_017607851.1 LN:5396
@SQ SN:NW_017607852.1 LN:5050
@SQ SN:NW_017607853.1 LN:5873
@SQ SN:NW_017607854.1 LN:5692
@SQ SN:NW_017607855.1 LN:11509
@SQ SN:NW_017607856.1 LN:12722
@SQ SN:NW_017607857.1 LN:42555
@SQ SN:NW_017607858.1 LN:11917
After reading up on the SAM file format, you know that the "@" sign means that we are in the headings
section, not the alignment section! The sam file is quite large so there is little purpose in scrolling to find
the alignments section (the file is also much too large for using the "grep" command to locate the
alignment section). Because of the density of the sam file, it is compressed to binary to create a more
easily tractable file for manipulation by future programs.
Usage:

Usage: samtools [command] [options] in.sam
Command:
view

prints all alignments in the specified input alignment file (in SAM, BAM, or

CRAM format) to standard output in SAM format
Options:
-h

Include the header in the output

-S

Indicate the input was in SAM format

-u

Output uncompressed BAM. This option saves time spent on

compression/decompression and is thus preferred when the output is piped to another
samtools command
-@

Number of processors

Usage: samtools [command] [-o out.bam]
Command:
sort

Sort alignments by leftmost coordinates

-o

Write the final sorted output to FILE, rather than to standard output.

The sam file then need to be converted in to bam format:
In [ ]:

%%bash
samtools sort -@ 4 -o sam/sort_SRR1964648.bam sam/SRR1964648.sam

5. Generating Total Read Counts
from Alignment using htseq-count
Now we will be using the htseq-count program to count the reads which were mapped to the genome. As
we talked about in lecture, htseq-count can quanitfy the number of reads in multiple ways. The figure
below depicts the different run modes how the program will count reads. The "union" mode is typically
the most common to use and the default option.

Usage:

Usage: htseq-count [options] alignment_file gff_file
Options:

-f SAMTYPE, --format=SAMTYPE
type of

data, either 'sam' or 'bam'

(default: sam)
-r ORDER, --order=ORDER
'pos' or 'name'. Sorting order of
(default: name). Paired-end sequencing data must be
sorted either by position or by read name, and the
sorting order must be specified. Ignored for singleend data.
-s STRANDED, --stranded=STRANDED
whether the data is from a strand-specific assay.
Specify 'yes', 'no', or 'reverse' (default: yes).
'reverse' means 'yes' with reversed strand
interpretation
-t FEATURETYPE, --type=FEATURETYPE
feature type (3rd column in GFF file) to be used, all
features of other type are ignored (default, suitable
for Ensembl GTF files: exon)
-i IDATTR, --idattr=IDATTR
GFF attribute to be used as feature ID (default,
suitable for Ensembl GTF files: gene_id)
-m {union,intersection-strict,intersection-nonempty}, --mode
mode to handle reads overlapping more than one feature
(choices: union, intersection-strict, intersectionnonempty; default: union)
Command to count reads per feature using htseq-count:

DATA="/home/WWU/BIOL497R/data/RNAseq"
htseq-count -s no -r pos -t gene -i Dbxref -f bam $DATA/sam/sort_SRR1964648.bam
L_crocea.gff > $DATA/counts/SRR1964648.counts
Once all the bam files have been counted, we will be having the following files in the counts directory.

counts/
├── SRR1964642.counts
├── SRR1964643.counts
├── SRR1964644.counts
├── SRR1964645.counts
├── SRR1964646.counts
├── SRR1964647.counts
├── SRR1964648.counts
└── SRR1964649.counts
Let's have a look at the contents of a counts file:

In [ ]:

%%bash
DATA="/home/WWU/BIOL497R/data/RNAseq"
head $DATA/counts/SRR1964648_1.counts
We see the layout is quite straightforward, with two columns separated by a tab. The first column identifies
the gene from the eponymous sample and the second column is the number of mRNA strands from the
row's gene found in the sample. This setup is perfect for our next task, identifying differentially expressed
genes.

A. Assignment 3 Activity 1:
Most of the code that has been provided thus far has been for processing a single library. In this activity,
modify the code and process the library that has been assigned to you in the table. Note, you will need
to adjust the output directorys to somewhere in your home directory ~/.
username

library

beavert2

SRR1964645_1

benedil

SRR1964649_1

browned

SRR1964643_1

faruqiw

SRR1964644_1

guilfon

SRR1964642_1

kingm28

SRR1964642_1

lethamt

SRR1964643_1

mccurdb

SRR1964649_1

mchughc4 SRR1964645_1
mooreb20

SRR1964647_1

moraldk

SRR1964646_1

rosalew

SRR1964646_1

santang

SRR1964645_1

solemw

SRR1964649_1

stuefes

SRR1964646_1

thuetdt

SRR1964647_1

turmang

SRR1964644_1

heimerl

SRR1964642_1

vangaea

SRR1964644_1

For your library, please report the (A) code used, (B) hisat2 message report (example below), the (C)

number of reads that had mapped but were not associated with a feature (use htseq-count) and (D)
provide an explanation of how RNAseq reads could map but not occur in a gene feature.
EXAMPLE: hisat2 report

25754901 reads; of these:
25754901 (100.00%) were unpaired; of these:
1793224 (6.96%) aligned 0 times
21247602 (82.50%) aligned exactly 1 time
2714075 (10.54%) aligned >1 times
93.04% overall alignment rate
In [ ]:

%%bash
#QA
#First, I transitioned to the directory containing the trimmed version of the library
(/home/WWU/BIOL497R/data/RNAseq/quality_control) that I was assigned, and copied it to
a directory I made
cp -Rp ./SRR1964645_1.scythe.sickle.fastq ~/ass3_trimmed_library/
#next, I created the necessary sam file and put it in another directory of my creation
hisat2 -p 4 --dta -x L_crocea -q
~/ass3_trimmed_library/SRR1964645_1.scythe.sickle.fastq -S sam_homework/SRR1964645.sam
#QB
24332958 reads; of these:
24332958 (100.00%) were unpaired; of these:
2055983 (8.45%) aligned 0 times
19914386 (81.84%) aligned exactly 1 time
2362589 (9.71%) aligned >1 times
91.55% overall alignment rate
#QC
#Next to convert the sam file to a bam file
samtools sort -@ 4 -o sam_homework/sort_SRR1964645.bam sam_homework/SRR1964645.sam
#Next, htseq-count to see gene features and the number of reads that aligned to them (i
was not aware that the output of the code was the file name, so it is not exactly what
I wanted it to be)
htseq-count --nonunique all -s no -r pos -t gene -i Dbxref -f bam
sam_homework/sort_SRR1964645.bam L_crocea.gff > counts_homework
#2664092 reads had no gene feature
#QD
#it is possible that reads the mapped but did not occur in a gene feature because of a

gene that has not been fully sequenced in the reference or possibly an over-active
polymerase

6. Differential expression with counts
and edgeR
This part of the tutorial can be run in the notebbook using %%R at the beginning of code blocks or in
RStudio.
The first thing we need to do before we can start the differential expression analysis is load the counts
data and metadata into R. To do this we will need to merge multiple htseq-count files and we want to
merge each of the values based on the gene name. Below is a schematic of what we want to accomplish.

Each htseq-count file has two columns, first being gene ids and second being read counts and you wish to
make a single table that contains values for each gene and library. To do this we will use the
multMergeHTseq function from the R package fastOC. This function requires a folder path, patterns to
identify files and library names. Below is a default usage:

Usage
multMergeHTseq(mypath, pattern="*\\.htseq", byY="gene",
RegEx="(\\w+)\\.htseq\\.txt", Replace="\\1", sep="\t")
In [1]:

%%R
require(fastOC, warn.conflicts = F, quietly = T);
#read counts data
count_data<-multMergeHTseq("/home/WWU/BIOL497R/data/RNAseq/counts/",
pattern="*\\.counts", byY="gene",
RegEx="(\\w+)\\.counts", Replace="\\1", sep="\t")
print(head(count_data, n=10))
R[write to console]:
Attaching package: ‘igraph’

R[write to console]: The following objects are masked from ‘package:stats’:
decompose, spectrum

R[write to console]: The following object is masked from ‘package:base’:
union

R[write to console]:
Attaching package: ‘fastcluster’

R[write to console]: The following object is masked from ‘package:stats’:
hclust

R[write to console]:
R[write to console]: Registered S3 methods overwritten by 'ggplot2':
method

from

[.quosures

rlang

c.quosures

rlang

print.quosures rlang
R[write to console]:
Attaching package: ‘WGCNA’

R[write to console]: The following object is masked from ‘package:stats’:
cor

gene SRR1964642_1 SRR1964643_1 SRR1964644_1 SRR1964645_1
1

__alignment_not_unique

2507014

2553005

2255293

2382527

2

__ambiguous

445542

424579

500885

491950

3

__no_feature

2811192

2696673

2666574

2663260

4

__not_aligned

1895026

1951899

1929855

2056246

5

__too_low_aQual

0

0

0

0

6

GeneID:104917625

19

41

29

14

7

GeneID:104917626

7

6

12

18

8

GeneID:104917627

0

0

0

0

9

GeneID:104917628

208

195

251

264

10

GeneID:104917629

71

71

62

60

SRR1964646_1 SRR1964647_1 SRR1964648_1 SRR1964649_1
1

2081349

2098640

2719984

2618154

2

459333

420210

763791

725148

3

2649892

2518167

2155544

2057220

4

1846459

2007052

1793377

1766530

5

0

0

0

0

6

5

50

0

4

7

6

13

9

16

8

2

1

1

1

9

222

220

149

144

10

172

179

41

41

Next, we can use the count_data object to plot the number of reads that were mapped to genes in each
library. The mapped reads is very important information because these are the actual data points that we
will be using for our analysis. Also, based on the output of count_data, you probably notice that there are
lines not associated with GeneID and for our analysis these line need to be removed.
Histograms are a great way to look at the amount of data that was generated for each of the RNAseq
libraries and provides another estimate of the quality for each sample. In the lecture, we mentioned that
scientists should be designing RNAseq experiments to obtain approximately 10 million reads per library
(10^7). These estimates are often calcualted based on the theoretical output of a sequencing machine and
some number of samples. In actuality, our samples are highly heterogeneous and it is difficult for
sequencing machines to equally sample each library because of differences in the RNA pool and
concentration. This results in some libraries being over sampled (i.e. more reads) or under sampled.
In [2]:

%%R
#reformat count_data
count_gene<-count_data[-c(1:5),-1]
row.names(count_gene)<-count_data[-c(1:5),1]
lib_size<-log10(colSums(count_gene))
hist(lib_size, xlab="log10 of Library Size")

A. Using EdgeR:
The next step is to contruct the differential expression object that we will use for our statitical analysis. To
identify differentially expressed genes, we will use the edgeR package within Bioconductor in R to perform
normalization and statistical analysis of differences among our two sample groups. The edgeR vignette
associated with the package comes with complete instructions on how to use edgeR for analysis. If you are
ever confused, visit the vignette, find the appropriate step and read up. This is true for most Bioconductor
packages. Now, let's begin loading our data:
In [3]:

%%R
#load packages
require(edgeR, warn.conflicts = F, quietly = T)
lib_names<-names(count_gene)
#load metadata information about the experiment and assign row names based on library
name
#this will allow for us to quickly reference things by library
metadata<-read.table("RNAseq_metadata.txt",sep="\t", header=TRUE, row.names=1)

print(metadata)
#build the statistical model
design <- model.matrix(~ metadata[lib_names,"condition"])
#create EdgeR object
y <- DGEList(counts = count_gene[,lib_names],
group = metadata[lib_names,"condition"],
remove.zeros = TRUE )
R[write to console]: Removing 5712 rows with all zero counts

fileName condition
SRR1964648_1 SRR1964648_1.counts

LF1A

SRR1964649_1 SRR1964649_1.counts

LF1A

SRR1964646_1 SRR1964646_1.counts

LA2A

SRR1964647_1 SRR1964647_1.counts

LA2A

SRR1964642_1 SRR1964642_1.counts

LB2A

SRR1964643_1 SRR1964643_1.counts

LB2A

SRR1964644_1 SRR1964644_1.counts

LC2A

SRR1964645_1 SRR1964645_1.counts

LC2A

When we are loading the count data and the conditions associated with the experiment, it is essential that
columns and rows match up. To do this we use the lib_name in the square bracket to re-order the
count_gene and metadata objects when we construct the inputs for edgeR.

B. Normalization:
edgeR is concerned with differential expression analysis rather than with the quantification of expression
levels. It is concerned with relative changes in expression levels between conditions, but not directly with
estimating absolute expression levels. This greatly simplifies the technical influences that need to be taken
into account, because any technical factor that is unrelated to the experimental conditions should cancel
out of any differential expression analysis. For example, read counts can generally be expected to be
proportional to length as well as to expression for any transcript, but edgeR does not generally need to
adjust for gene length because gene length has the same relative influence on the read counts for each
RNA sample. For this reason, normalization issues arise only to the extent that technical factors have
sample-specific effects.

Sequencing Depth¶
The most obvious technical factor that affects the read counts, other than gene expression levels, is the
sequencing depth of each RNA sample. edgeR adjusts any differential expression analysis for varying
sequencing depths as represented by differing library sizes. This is part of the basic modeling procedure

and flows automatically into fold-change or p-value calculations. It is always present, and doesn’t require
any user intervention.

RNA composition¶
The second most important technical influence on differential expression is one that is less obvious. RNAseq provides a measure of the relative abundance of each gene in each RNA sample, but does not provide
any measure of the total RNA output on a per-cell basis. This commonly becomes important when a small
number of genes are very highly expressed in one sample, but not in another. The highly expressed genes
can consume a substantial proportion of the total library size, causing the remaining genes to be undersampled in that sample. Unless this RNA composition effect is adjusted for, the remaining genes may
falsely appear to be down-regulated in that sample [32]. The calcNormFactors function normalizes for RNA
composition by finding a set of scaling factors for the library sizes that minimize the log-fold changes
between the samples for most genes. The default method for computing these scale factors uses a
trimmed mean of M- values (TMM) between each pair of samples [32]. We call the product of the original
library size and the scaling factor the effective library size. The effective library size replaces the original
library size in all downsteam analyses. TMM is the recommended for most RNA-Seq data where the
majority (more than half) of the genes are believed not differentially expressed between any pair of the
samples. The following commands perform the TMM normalization and display the normalization factors.
In [4]:

%%R
#normalize the counts
y <-calcNormFactors(y,method="TMM")
print(y$samples)
group lib.size norm.factors
SRR1964642_1

LB2A 16728656

1.0203476

SRR1964643_1

LB2A 16310120

1.0219279

SRR1964644_1

LC2A 16589180

0.9458618

SRR1964645_1

LC2A 16738975

0.9509216

SRR1964646_1

LA2A 15936634

1.1206806

SRR1964647_1

LA2A 15622082

1.1203915

SRR1964648_1

LF1A 18322205

0.9190539

SRR1964649_1

LF1A 17513558

0.9239885

Biological coefficient of variation (BCV)¶
Biological coefficient of variation is the coefficient of variation with which the (unknown) true abundance of
the gene varies between replicate RNA samples. It represents the coefficient of variation (CV) that would
remain between biological replicates if sequencing depth could be increased indefinitely. The technical CV
decreases as the size of the counts increases. BCV on the other hand does not. BCV is therefore likely to
be the dominant source of uncertainty for high-count genes, so reliable estimation of BCV is crucial for

realistic assessment of differential expression in RNA-Seq experiments. If the abundance of each gene
varies between replicate RNA samples in such a way that the genewise standard deviations are
proportional to the genewise means, a commonly occurring property of measurements on physical
quantities, then it is reasonable to suppose that BCV is approximately constant across genes. We allow
however for the possibility that BCV might vary between genes and might also show a systematic trend
with respect to gene expression or expected count.
The magnitude of BCV is more important than the exact probabilistic law followed by the true gene
abundances. For mathematical convenience, we assume that the true gene abundances follow a gamma
distributional law between replicate RNA samples. This implies that the read counts follow a negative
binomial probability law.
The parallel nature of sequencing data allows some possibilities for borrowing information from the
ensemble of genes which can assist in inference about each gene individually. The easiest way to share
information between genes is to assume that all genes have the same mean-variance relationship, in other
words, the dispersion is the same for all the genes. An extension to this “common dispersion” approach is
to put a mean-dependent trend on a parameter in the variance function, so that all genes with the same
expected count have the same variance.
However, the truth is that the gene expression levels have non-identical and dependent distribution
between genes, which makes the above assumptions too naive. A more general approach that allows
genewise variance functions with empirical Bayes moderation was in- troduced several years ago and was
extended to generalized linear models and thus more complex experimental designs. Only when using
tagwise dispersion will genes that are consistent between replicates be ranked more highly than genes
that are not. It has been seen in many RNA-Seq datasets that allowing gene-specific dispersion is
necessary in order that differential expression is not driven by outliers. Therefore, the tagwise dispersions
are strongly recommended in model fitting and testing for differential expression.
In [5]:

%%R
#estimate dispersion parameters
y <-estimateDisp(y,design)
plotBCV(y)

In the plot above, the counts per million (CPM) per gene were plotted versus the BCV. First if we look at the
individual dots which represent the average CPM per gene, it is obvious that genes with a low expression
have a higher BCV and suggests that the "true" abundance of a gene varies widely for low expressed
genes. Second, the common (red) and trend (blue) lines show a different pattern and suggest that overall
(across all genes) there is not systemic bias between expression and the BCV.

C. Comparision between groups:
Pairwise comparisons between two groups¶
For all the Next-Gen squencing data analyses we consider here, people are most interested in finding
differentially expressed genes/tags between two groups. Once negative binomial models are fitted and
dispersion estimates are obtained, we can proceed with testing procedures for determining differential
expression using the exact test. Knowing the conditional distribution for the sum of counts in a group, we
can compute exact p-values by summing over all sums of counts that have a probability less than the
probability under the null hypothesis of the observed sum of counts. The exact test for the negative
binomial distribution has strong parallels with Fisher’s exact test and students t-test.
In [6]:

%%R

#compare the expression between two groups
#FC would be: in comparison to LB2A, how much did LA2A change
et <- exactTest(y, pair=c("LB2A","LA2A"))
print(topTags(et))
summary(de <- decideTestsDGE(et))
Comparison of groups:

LA2A-LB2A
logFC

logCPM PValue FDR

GeneID:104926391

7.586340 5.933987

0

0

GeneID:104928771

6.807888 4.950548

0

0

GeneID:104933695

6.499897 6.811360

0

0

GeneID:109140403

6.286977 6.272070

0

0

GeneID:104922455

5.651180 6.104874

0

0

GeneID:104934661 -5.387295 6.411142

0

0

GeneID:104928555

5.287449 8.369240

0

0

GeneID:104924692

5.237711 6.342894

0

0

GeneID:104930671

4.878314 4.762571

0

0

GeneID:104931795

4.834677 5.243110

0

0

LA2A-LB2A
Down
NotSig
Up

5476
10568
5483

More complex experiments (glm)¶
Generalized linear models (GLMs) are an extension of classical linear models to nonnormally distributed
response data. GLMs specify probability distributions according to their mean-variance relationship, for
example the quadratic mean-variance relationship specified above for read counts. For general
experiments, once dispersion estimates are obtained and negative binomial generalized linear models are
fitted, we can proceed with testing procedures for determining differential expression using either quasilikelihood (QL) F-test or likelihood ratio test.
In our experiment, we consider the four treatment groups, each with two replicates, and the researcher
wants to make pairwise comparisons between them. A QL model representing the study design can be
fitted to the data with commands such as:
In [7]:

%%R
#determined from design matrix
#LA2A = 1 (intercept)
#LB2A = 2 (control)
#LC2A = 3

#LF1A = 4
fit <- glmQLFit(y, design)
#in comparison to LA2A (1) how much did LB2A (2) change:
qlf.2vs1 <- glmQLFTest(fit, coef=2)
topTags(qlf.2vs1)
Coefficient:

metadata[lib_names, "condition"]LB2A
logFC

logCPM

F

PValue

FDR

GeneID:104929331 -4.662615 10.507850 515409.30 7.989044e-15 1.719802e-10
GeneID:104938146 -2.713635 11.248578 178585.52 1.452264e-13 1.563145e-09
GeneID:104935382 -2.923986

9.459917 120439.21 4.267421e-13 2.209608e-09

GeneID:104926156 -3.267658

8.336306 118812.58 4.429191e-13 2.209608e-09

GeneID:104925216 -3.512231

6.115416 104294.17 6.327081e-13 2.209608e-09

GeneID:104940059 -3.219008 10.234265

99491.48 7.198231e-13 2.209608e-09

GeneID:104928555 -5.287403

8.369240

95649.66 8.017193e-13 2.209608e-09

GeneID:104940315

2.985962

9.589646

91076.81 9.167217e-13 2.209608e-09

GeneID:104926919 -2.958653

8.363649

88010.16 1.006790e-12 2.209608e-09

GeneID:104923865 -2.579144

8.103076

87390.76 1.026436e-12 2.209608e-09

In [8]:

%%R
#in comparison to LB2A (2) how much did LC2A (3) change:
qlf.3vs2 <- glmQLFTest(fit, contrast=c(0,-1,1,0))
topTags(qlf.3vs2)
Coefficient:

-1*metadata[lib_names, "condition"]LB2A 1*metadata[lib_names,

"condition"]LC2A
logFC
GeneID:104933461 -4.746763

logCPM

F

PValue

FDR

8.562723 196224.37 1.122308e-13 2.415993e-09

GeneID:104929331

2.145491 10.507850 130903.15 3.397512e-13 2.757067e-09

GeneID:104928555

5.862203

8.369240 115669.56 4.766326e-13 2.757067e-09

GeneID:104925605

5.565889

8.801819

91955.20 8.929591e-13 2.757067e-09

GeneID:104929232

2.900187

8.075037

88105.59 1.003809e-12 2.757067e-09

GeneID:109136649

6.391099

6.162314

87194.54 1.032769e-12 2.757067e-09

GeneID:104939928 -4.155949

7.079037

82857.22 1.187503e-12 2.757067e-09

GeneID:104932538

2.480165

8.499745

78497.45 1.376788e-12 2.757067e-09

GeneID:104921782

2.894438

6.500516

78257.04 1.388392e-12 2.757067e-09

GeneID:104927028 -3.307354

6.902796

76946.89 1.454035e-12 2.757067e-09

In [9]:

%%R

#To find genes different between any of the four groups:
qlf <- glmQLFTest(fit, coef=2:4)
topTags(qlf)
Coefficient:

metadata[lib_names, "condition"]LB2A metadata[lib_names, "condition"]LC2A

metadata[lib_names, "condition"]LF1A
logFC.metadata.lib_names...condition..LB2A
GeneID:104931936

2.9113275

GeneID:104940476

1.6891359

GeneID:104929331

-4.6626153

GeneID:104940626

1.3671129

GeneID:104933461

1.1105738

GeneID:104918527

-0.7181912

GeneID:104930094

0.8189547

GeneID:104931901

-2.6571446

GeneID:104922235

1.3931366

GeneID:104936356

-0.6135350
logFC.metadata.lib_names...condition..LC2A

GeneID:104931936

1.0655905

GeneID:104940476

3.8903596

GeneID:104929331

-2.5171238

GeneID:104940626

3.0095840

GeneID:104933461

-3.6361889

GeneID:104918527

1.2290692

GeneID:104930094

1.5653284

GeneID:104931901

-3.2075621

GeneID:104922235

1.0381296

GeneID:104936356

0.4578227
logFC.metadata.lib_names...condition..LF1A

logCPM

F

GeneID:104931936

16.802471 10.837218 909608.5

GeneID:104940476

8.915673 10.468004 529463.3

GeneID:104929331

-5.566642 10.507850 364597.8

GeneID:104940626

-1.198524 12.214626 165007.4

GeneID:104933461

-5.070116

8.562723 137299.5

GeneID:104918527

3.394101 11.270728 115453.8

GeneID:104930094

-2.560272 10.829675 112684.3

GeneID:104931901

5.097795

GeneID:104922235

8.035376 110657.3

-2.601616 14.164948 108573.7

GeneID:104936356

3.024494
PValue

FDR

GeneID:104931936 5.406763e-16 1.163914e-11
GeneID:104940476 2.377034e-15 2.558521e-11
GeneID:104929331 6.597605e-15 4.734221e-11
GeneID:104940626 5.774867e-14 3.107889e-10

9.351297 108553.9

GeneID:104933461 9.549840e-14 3.909762e-10
GeneID:104918527 1.534388e-13 3.909762e-10
GeneID:104930094 1.639794e-13 3.909762e-10
GeneID:104931901 1.723298e-13 3.909762e-10
GeneID:104922235 1.815305e-13 3.909762e-10
GeneID:104936356 1.816213e-13 3.909762e-10
Often it is important to capture all the DE genes and write them to a table. To do this we can modify the
options in the decideTestsDGE function to give us all the genes.
In [10]:

%%R
#get the number of DE genes and store the results in lrt$table
de.qlf <- decideTestsDGE(qlf)
qlf$table[,5]<-de.qlf
names(qlf$table)[5]<-"Decide_test"
write.table(qlf$table,file="DE_genes.csv", sep=",", quote=F)

D. Common plots for differential expression
analysis:
For our differential expression analysis, we will be using three types of graphs to visualize the data: BlandAltman (MA), heatmap, and PCA plots.
Bland-Altman (smear) Plot
The Bland-Altman plot is a binary analysis, gathering information on the relationships between two-sets of
data. Because we have eight sets of data, we will be breaking our data into separate groups based on
treatments (LB2A, LC2A, LA2A and LF1A). For this exercise we will be starting with the control group
(LB2A) and thermal stress group (LC2A) comparisons, then generating two superimposed plots comparing
each member of the two groups to each member of the other group. Before we go further, what is a BlandAltman plot? An smear plot is the comparison of the log-differences for two datasets to the log-averages.

M = log2(D1/D2) = log2(D1)-log2(D2)
A = ½log2(D1D2) = ½(log2(D1)+log2(D2))
with D1 and D2 being datasets 1 and 2, respectively. We plot M on the vertical axis and A on the horizontal
axis. We see here that should two datapoints from datasets 1 and 2 be equal, they will plot at (D1==D2,
0). Therefore, should our entire plot run along y=0, it is safe to say, that for us, none of our genes were
differentially expressed. However, should there be large deviations from y=0, we are provided with insight
that we may have differentially expressed genes.
Heatmap
Heatmaps are the most readily readable visualizations for determining differential expression. Heatmaps

are discrete plots. That is, the values along the x and y axis move in integer increments, with no places inbetween. Typically, the x-and-y axes contain different types of information about each dataset, and
combine to capture the whole image of the dataset. For us, we may find it useful to make one axis our
groups (our four datasets) and the other axis the genes sampled from those datasets. Now each cell in our
grid will correspond to the expression of a gene from a sample. We then assign a color-palette to each
possible range of gene expression. For instance, an expression between 300-500 may be blue while an
expression of 501-1000 may be violet. After coloring all of our cells responsibly, we now have simple,
discrete snapshots of each datasets expression distribution. Should we notice that two groups have very
similar looking snapshots, we may cluster those groups safely with the assumption that they do not share
differentially expressed genes, and therefore belong to the same space.
Multidimensional scaling (MDS)
Multidimensional scaling (MDS) is a technique used to emphasize variation and bring out strong patterns in
a dataset. It's often used to make data easy to explore and visualize. It is a mathematical procedure that
transforms a number of corrlated variables into similarity distances that approximate the expression
differences between the samples. Typically these are plotted in two-dimensional scatterplots but realized
that these can be complex multi-dimensional plots.
In [11]:

%%R
#plot Bland-Altman(smear) Plot
detags <- rownames(y)[as.logical(decideTestsDGE(exactTest(y, pair=c("LB2A","LA2A"))))]
plotSmear(y,pair=c("LB2A","LA2A"), de.tags=detags)

In [12]:

%%R
require("RColorBrewer", quiet=T)
#plot heatmap of samples
#convert counts to euclidean distances
sampleDists <- as.matrix(dist(t(count_gene)))

cimColor <- colorRampPalette(rev(brewer.pal(9, "Blues")))(16)
heatmap(sampleDists, col=cimColor, margin = c(8,8))

In [13]:

%%R
#create heatmap with a subset of DE genes
detags <- rownames(y)[as.logical(decideTestsDGE(exactTest(y, pair=c("LB2A","LC2A"))))]
#plot heatmap of samples and genes
heatmap(as.matrix(count_gene[detags,c("SRR1964642_1", "SRR1964643_1", "SRR1964644_1",
"SRR1964645_1")]), margin = c(8,8))

In [37]:

%%R
##compare libraries by plots MDS ordnation of samples
plotMDS(y,top=10000, labels=metadata[lib_names,"condition"])

7. Integrating the DE Results with
the Annotation Results
Once the differentially expressed genes have been identified, we need to annotate the genes to identify
the function. To do this we will be merging the DE gene list from above with the funtional annotation of the
gene features. First lets look at the structure of the two tables.
In [17]:

%%R
DE_genes<-read.csv("DE_genes.csv")
print("DE gene table")
print(head(DE_genes, n=3))
annotat<-read.csv("ProteinTable12197_229515.txt", sep="\t", header=T)

print("Gene annotation table")
print(head(annotat, n=3))

[1] "DE gene table"
logFC.metadata.lib_names...condition..LB2A
GeneID:104917625

0.1925568

GeneID:104917626

-0.4717997

GeneID:104917627

-3.6258488
logFC.metadata.lib_names...condition..LC2A

GeneID:104917625

-0.1922151

GeneID:104917626

0.8122524

GeneID:104917627

-3.6258488
logFC.metadata.lib_names...condition..LF1A

logCPM

-3.6030595

0.4125387

GeneID:104917625
GeneID:104917626

0.4890006 -0.3764740

GeneID:104917627

-0.4400520 -2.6708856
Decide_test

PValue

GeneID:104917625

0 0.24524629

GeneID:104917626

0 0.15144076

GeneID:104917627

0 0.07698883

[1] "Gene annotation table"
X.Replicon.Name Replicon.Accession Start Stop Strand

GeneID

Locus

1

Un

NW_017607850.1

71 6306

+ 109136730 LOC109136730

2

Un

NW_017607851.1

1839 5198

- 104920847 LOC104920847

3

Un

NW_017607853.1

7

656

- 109141431 LOC109141431

Protein.product Length
1

XP_019114579.1

552

2

XP_019122094.1

153

3

XP_019129876.1

217
Protein.name

1 PREDICTED: MORC family CW-type zinc finger protein 3-like
2

PREDICTED: UBX domain-containing protein 2A, partial

3

PREDICTED: uncharacterized protein K02A2.6-like, partial

What we notice is that the name of features between the two tables does not line up perfectly. The
DE_genes table labels genes with GeneID:\d+ and the annotat table contains gene numbers in column 16
(GeneID). In order to merge these two tables we need to manipulate the names in one of the tables.
Personally, I think it is easier to remove "GeneID:" from the DE_gene object.
In [18]:

%%R
row.names(DE_genes)<-sub("GeneID\\:(\\d+)", "\\1", row.names(DE_genes), perl=TRUE )
head(DE_genes)
logFC.metadata.lib_names...condition..LB2A
104917625

0.19255682

104917626

-0.47179971

104917627

-3.62584875

104917628

-0.06532926

104917629

-1.23620599

104917630

2.16673036
logFC.metadata.lib_names...condition..LC2A

104917625

-0.1922151

104917626

0.8122524

104917627

-3.6258488

104917628

0.3822346

104917629

-1.3609742

104917630

-1.6374119
logFC.metadata.lib_names...condition..LF1A

104917625

-3.6030595

logCPM Decide_test
0.4125387

0

104917626

0.4890006 -0.3764740

0

104917627

-0.4400520 -2.6708856

0

104917628

-0.4939666

3.6424151

1

104917629

-1.9957017

2.4123756

1

104917630

3.0016780

0.2767365

1

PValue
104917625 2.452463e-01
104917626 1.514408e-01
104917627 7.698883e-02
104917628 2.118637e-06
104917629 2.498882e-07
104917630 8.077861e-06
In addition, we need to remove duplicate genes from the annotation file because it contains isoform
information which we are not using in this analysis.
In [19]:

%%R
#this will return boolean (TRUE or FALSE) if name is a duplicate
index<-duplicated(annotat[,"GeneID"])
#remove duplicated gene names
annotat<-annotat[!index,]
head(annotat)
X.Replicon.Name Replicon.Accession Start

Stop Strand

GeneID

Locus

1

Un

NW_017607850.1

71

6306

+ 109136730 LOC109136730

2

Un

NW_017607851.1

1839

5198

- 104920847 LOC104920847

3

Un

NW_017607853.1

7

656

- 109141431 LOC109141431

4

Un

NW_017607862.1 32281 34802

+ 109137990 LOC109137990

5

Un

NW_017607863.1 14251 16230

+ 109138189 LOC109138189

6

Un

NW_017607869.1

+ 104939476 LOC104939476

466

8284

Protein.product Length
1

XP_019114579.1

552

2

XP_019122094.1

153

3

XP_019129876.1

217

4

XP_019112777.1

434

5

XP_019113565.1

188

6

XP_019117313.1

520
Protein.name

1 PREDICTED: MORC family CW-type zinc finger protein 3-like
2

PREDICTED: UBX domain-containing protein 2A, partial

3

PREDICTED: uncharacterized protein K02A2.6-like, partial

4

PREDICTED: zinc finger MYM-type protein 1-like

5

PREDICTED: unconventional myosin-XIX-like, partial

6

PREDICTED: BCL-6 corepressor-like

Lastly, we merge the two data frames based on the GeneIDs by specifying the by.x column that should be
matched to the by.y column. The most interesting column in this larger data frmae is the Protein.name
because it gives a description of the protein.
In [20]:

%%R
DE_annotat<- merge(DE_genes, annotat, by.x="row.names", by.y="GeneID", all.x=T)
write.table(DE_annotat, file="DE_genes_annotation.txt", sep="\t", quote=F, row.names=F)
head(DE_annotat)
Row.names logFC.metadata.lib_names...condition..LB2A
1 104917625

0.19255682

2 104917626

-0.47179971

3 104917627

-3.62584875

4 104917628

-0.06532926

5 104917629

-1.23620599

6 104917630

2.16673036

logFC.metadata.lib_names...condition..LC2A
1

-0.1922151

2

0.8122524

3

-3.6258488

4

0.3822346

5

-1.3609742

6

-1.6374119

logFC.metadata.lib_names...condition..LF1A
1

-3.6030595

logCPM Decide_test
0.4125387

0

2

0.4890006 -0.3764740

0

3

-0.4400520 -2.6708856

0

4

-0.4939666

3.6424151

1

5

-1.9957017

2.4123756

1

6

3.0016780

0.2767365

1

PValue X.Replicon.Name Replicon.Accession

Start

Stop Strand

1 2.452463e-01

Un

NW_017609675.1 144946 149088

-

2 1.514408e-01

Un

NW_017608176.1 460798 462779

-

3 7.698883e-02

Un

NW_017608176.1 453945 459087

-

4 2.118637e-06

Un

NW_017608176.1 439125 446663

+

5 2.498882e-07

Un

NW_017608176.1 433394 437134

+

6 8.077861e-06

Un

NW_017608176.1 397721 422136

+

Locus Protein.product Length
1 LOC104917625

XP_019134062.1

364

2 LOC104917626

XP_010727421.2

196

3

syngr3

XP_010727422.1

230

4

znf598

XP_010727423.2

923

5 LOC104917629

XP_010727424.2

312

6 LOC104917630

XP_010727426.1

221
Protein.name

1 PREDICTED: developmentally-regulated GTP-binding protein 2
2

PREDICTED: FAD-linked sulfhydryl oxidase ALR

3

PREDICTED: synaptogyrin-3

4

PREDICTED: zinc finger protein 598

5

PREDICTED: peroxisomal membrane protein PMP34-like

6

PREDICTED: rho GDP-dissociation inhibitor 1 isoform X2

Assignment 3 Activity 2:
How do the results from the comparison of LB2A and LF1A compare to the findings from Qian et al., 2016.
Liver Transcriptome Analysis of the Large Yellow Croaker?
To do this you will need to (A) calculate the differentially expressed genes between LB2A and LF1A using a
glm model and annotate the results using ProteinTable12197_229515.txt.
(B) How many genes were differentially expressed in comparison to Qian et al?
(C) Why might they be the same or different?
Table 2 from Qian et al. describes the major genes that were differnetially expressed, using the Gene
names: GOT2, NPC1L1, MGAT2, MTTP and G6PC (D) compare their findings with your results.
In [42]:

%%R

##############QA############
et <- exactTest(y, pair=c("LB2A","LF1A"))
print(topTags(et))
summary(de <- decideTestsDGE(et))
Comparison of groups:

LF1A-LB2A
logFC

GeneID:104940483

logCPM PValue FDR

17.825626

8.763825

0

0

GeneID:104926267 -14.033857

5.267725

0

0

GeneID:104931936

13.891110 10.837218

0

0

GeneID:104931934

12.871881

9.817682

0

0

GeneID:104917769

12.643941

8.211020

0

0

GeneID:104922908

9.693944

3.819774

0

0

GeneID:104936497

-8.887674

5.338649

0

0

GeneID:104940475

8.715933

8.150866

0

0

GeneID:104931901

7.754906

8.035376

0

0

GeneID:109138937

-7.571996

7.292721

0

0

LF1A-LB2A
Down
NotSig

5154
11362

Up

5011

In [43]:

%%R
fit <- glmQLFit(y, design)
qlf.4vs2 <- glmQLFTest(fit, contrast=c(0,-1,0,1))
topTags(qlf.4vs2)
Coefficient:

-1*metadata[lib_names, "condition"]LB2A 1*metadata[lib_names,

"condition"]LF1A
logFC

logCPM

F

PValue

FDR

GeneID:104931936 13.891144 10.837218 993473.9 1.326236e-15 2.854988e-11
GeneID:104940476

7.226537 10.468004 646909.1 4.289840e-15 4.617369e-11

GeneID:104922235 -3.994752 14.164948 299609.8 3.525067e-14 2.529471e-10
GeneID:104933461 -6.180689

8.562723 264835.9 4.940577e-14 2.658895e-10

GeneID:104930094 -3.379227 10.829675 228172.6 7.427701e-14 2.800111e-10
GeneID:104918527

4.112292 11.270728 224083.8 7.804462e-14 2.800111e-10

GeneID:104936356

3.638029

9.351297 198380.3 1.089249e-13 3.349751e-10

GeneID:104918112 -3.343130

9.090803 183546.1 1.347369e-13 3.625602e-10

GeneID:104929461 -3.842183 14.116685 159876.8 1.965869e-13 4.392081e-10

GeneID:104940626 -2.565636 12.214626 156185.9 2.095608e-13 4.392081e-10
In [44]:

%%R
de.qlf.4vs2 <- decideTestsDGE(qlf.4vs2)
qlf.4vs2$table[,5]<-de.qlf.4vs2
names(qlf.4vs2$table)[5]<-"Decide_test_4vs2"
write.table(qlf.4vs2$table,file="DE_genes_4vs2.csv", sep=",", quote=F)
In [51]:

%%R
DE_genes_4vs2<-read.csv("DE_genes_4vs2.csv")
print("DE gene table")
print(head(DE_genes_4vs2, n=3))
annotat<-read.csv("ProteinTable12197_229515.txt", sep="\t", header=T)

print("Gene annotation table")
print(head(annotat, n=3))
[1] "DE gene table"
logFC

logCPM

F

PValue Decide_test_4vs2

GeneID:104917625 -3.7956163

0.4125387

4.937906 0.07228635

0

GeneID:104917626

0.9608003 -0.3764740

3.498694 0.11530490

0

GeneID:104917627

3.1857968 -2.6708856 19.664571 0.09334706

0

[1] "Gene annotation table"
X.Replicon.Name Replicon.Accession Start Stop Strand

GeneID

Locus

1

Un

NW_017607850.1

71 6306

+ 109136730 LOC109136730

2

Un

NW_017607851.1

1839 5198

- 104920847 LOC104920847

3

Un

NW_017607853.1

7

656

- 109141431 LOC109141431

Protein.product Length
1

XP_019114579.1

552

2

XP_019122094.1

153

3

XP_019129876.1

217
Protein.name

1 PREDICTED: MORC family CW-type zinc finger protein 3-like
2

PREDICTED: UBX domain-containing protein 2A, partial

3

PREDICTED: uncharacterized protein K02A2.6-like, partial

In [52]:

%%R

row.names(DE_genes_4vs2)<-sub("GeneID\\:(\\d+)", "\\1", row.names(DE_genes_4vs2),
perl=TRUE )
head(DE_genes_4vs2)
logFC

logCPM

104917625 -3.7956163

0.4125387

4.937906 7.228635e-02

0

104917626

0.9608003 -0.3764740

3.498694 1.153049e-01

0

104917627

3.1857968 -2.6708856

19.664571 9.334706e-02

0

104917628 -0.4286373

3.6424151 177.403238 9.770981e-05

-1

104917629 -0.7594957

2.4123756 142.082026 1.069950e-04

-1

104917630

0.2767365

0.8349476

F

PValue Decide_test_4vs2

44.132023 1.053885e-03

1

In [53]:

%%R
index<-duplicated(annotat[,"GeneID"])

annotat<-annotat[!index,]
head(annotat)
X.Replicon.Name Replicon.Accession Start

Stop Strand

GeneID

Locus

1

Un

NW_017607850.1

71

6306

+ 109136730 LOC109136730

2

Un

NW_017607851.1

1839

5198

- 104920847 LOC104920847

3

Un

NW_017607853.1

7

656

- 109141431 LOC109141431

4

Un

NW_017607862.1 32281 34802

+ 109137990 LOC109137990

5

Un

NW_017607863.1 14251 16230

+ 109138189 LOC109138189

6

Un

NW_017607869.1

+ 104939476 LOC104939476

466

8284

Protein.product Length
1

XP_019114579.1

552

2

XP_019122094.1

153

3

XP_019129876.1

217

4

XP_019112777.1

434

5

XP_019113565.1

188

6

XP_019117313.1

520
Protein.name

1 PREDICTED: MORC family CW-type zinc finger protein 3-like
2

PREDICTED: UBX domain-containing protein 2A, partial

3

PREDICTED: uncharacterized protein K02A2.6-like, partial

4

PREDICTED: zinc finger MYM-type protein 1-like

5

PREDICTED: unconventional myosin-XIX-like, partial

6

PREDICTED: BCL-6 corepressor-like

In [55]:

%%R
DE_annotat_4vs2<- merge(DE_genes_4vs2, annotat, by.x="row.names", by.y="GeneID",
all.x=T)
write.table(DE_annotat_4vs2, file="DE_genes_annotation_4vs2.txt", sep="\t", quote=F,
row.names=F)
head(DE_annotat_4vs2)
Row.names

logFC

logCPM

1 104917625 -3.7956163

0.4125387

4.937906 7.228635e-02

0

2 104917626

0.9608003 -0.3764740

3.498694 1.153049e-01

0

3 104917627

3.1857968 -2.6708856

19.664571 9.334706e-02

0

4 104917628 -0.4286373

3.6424151 177.403238 9.770981e-05

-1

5 104917629 -0.7594957

2.4123756 142.082026 1.069950e-04

-1

6 104917630

0.2767365

0.8349476

F

PValue Decide_test_4vs2

44.132023 1.053885e-03

X.Replicon.Name Replicon.Accession

Start

Stop Strand

1
Locus

1

Un

NW_017609675.1 144946 149088

- LOC104917625

2

Un

NW_017608176.1 460798 462779

- LOC104917626

3

Un

NW_017608176.1 453945 459087

-

syngr3

4

Un

NW_017608176.1 439125 446663

+

znf598

5

Un

NW_017608176.1 433394 437134

+ LOC104917629

6

Un

NW_017608176.1 397721 422136

+ LOC104917630

Protein.product Length
1

XP_019134062.1

364

2

XP_010727421.2

196

3

XP_010727422.1

230

4

XP_010727423.2

923

5

XP_010727424.2

312

6

XP_010727426.1

221
Protein.name

1 PREDICTED: developmentally-regulated GTP-binding protein 2
2

PREDICTED: FAD-linked sulfhydryl oxidase ALR

3

PREDICTED: synaptogyrin-3

4

PREDICTED: zinc finger protein 598

5

PREDICTED: peroxisomal membrane protein PMP34-like

6

PREDICTED: rho GDP-dissociation inhibitor 1 isoform X2

In [ ]:

#############QB###############
#I believe the key to this part of the assignment is to grep search for genes that have
a p value of 0.05 or less. I was not successful, however, in formulating such a grep

search. The best I could come up with was grep( "0[0-0.05]", P_values$PValue, value =
T) in R after copying/pasting the P values into a separate .csv file so I could search
them independently, this search, however, returns about 17,000 genes, many of which
have P values above 0.05, so it is clear that I do not understand regular expressions
well enough.
#with this in mind, it is possible that we could believe that every gene in this list
is differentially expressed, since this is what the exact test function served to find.
If this is the case, then there were 21,526 differentially expressed genes
In [ ]:

#########QC#############

#The most likely reason that my list would differ from Qian et al. is that they used a
two fold or greater change in expression to identify differentially expressed genes,
while I did not.
#Also, if it does turn out that I did not need to spend a lot of time trying to figure
out how to formulate the correct grep search, it is a much simpler explanation that my
differentially expressed genes had a much more permissive P value cutoff (if there even
was one)
In [ ]:

################QD#################

#GOT2- upregulated in qian et al (fold change 1.29), downregulated in this analysis (0.652)
#NPC1L1- upregulated to a much greater extent (2.39) in qian et al than in this
analysis (0.473)
#MGAT2- upregulated to a much greater extent (1.05) in qian et al than here (0.273)
#MTTP- Slightly more heavily downregulated (-2.88) in qian et al comapared to here (3.16)
#G6PC- Much more havily downregulated (-5.11) in qian et al than here (-0.021)

