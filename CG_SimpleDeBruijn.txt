De Bruijn Graph Tutorial
¶
Tutorial Outline¶
1. What is a De Bruijn Graph?
2. Set up environment
3. Python functions for De Bruijn Graphs
4. Examples
1. Graph a phrase
2. Graph a DNA sequence
3. Graph a polymorphic DNA sequence

1. What is a De Bruijn Graph?
De Bruijn graphs are graphical representations of sequences. They are used to assemble genomes from
short reads. The graph contains nodes of kmers connected by directional edges. A DNA sequence can be
generated by following the directional edges in the graph through a series of kmers.
We will introduce De Bruijn graphs by creating some graph from known sequences, rather than using
graphs to assemble an unknown sequence.

2. Set up environment
Note: The correct software has already been install but on different computers this will require the
installation of the python packages `graphviz` and `gvmagic`.
In [1]:

%load_ext gvmagic

3. Python functions for De Bruijn
Graphs
The following python functions generate a list of nodes and edges for a De Bruijn graph from an input
sequence (string of characters).
In [2]:

# generate the list of nodes and edges of size kmer+1
def de_bruijn_ize(st, k):
""" Return a list holding, for each k-mer, its left
k-1-mer and its right k-1-mer in a pair """
edges = []
nodes = set()
for i in range(len(st) - k + 1):
edges.append((st[i:i+k-1], st[i+1:i+k]))
nodes.add(st[i:i+k-1])
nodes.add(st[i+1:i+k])
return nodes, edges
def visualize_de_bruijn(nodes, edges):
""" Visualize a directed multigraph using graphviz """
dot_str = 'digraph "DeBruijn graph" {\n'
for node in nodes:
dot_str += '

%s [label="%s"] ;\n' % (node, node)

for src, dst in edges:
dot_str += '

%s -> %s ;\n' % (src, dst)

return dot_str + '}\n'

4. Examples
A. Graph a phrase
To demonstrate how De Bruijn graphs work, let's make a graph from the phrase "a long long long time".
In [3]:

nodes, edges = de_bruijn_ize("a_long_long_long_time", 5)
In [4]:

nodes
Out[4]:

{'_lon',
'_tim',
'a_lo',
'g_lo',
'g_ti',
'long',
'ng_l',
'ng_t',
'ong_',
'time'}
In [5]:

edges
Out[5]:

[('a_lo', '_lon'),
('_lon', 'long'),
('long', 'ong_'),
('ong_', 'ng_l'),
('ng_l', 'g_lo'),
('g_lo', '_lon'),
('_lon', 'long'),
('long', 'ong_'),
('ong_', 'ng_l'),
('ng_l', 'g_lo'),
('g_lo', '_lon'),
('_lon', 'long'),
('long', 'ong_'),
('ong_', 'ng_t'),
('ng_t', 'g_ti'),
('g_ti', '_tim'),
('_tim', 'time')]
In [6]:

%dotstr visualize_de_bruijn(nodes, edges)
g_lo _lon _tim time ng_l ng_t g_ti ong_ a_lo long
Can you trace the path through the graph that produces the original phrase? Why does the graph contain a
loop?
Let's try a slightly more complicated set of phrases.
In [7]:

nodes, edges =

de_bruijn_ize("fuzzy_wuzzy_was_a_bear_fuzzy_wuzzy_had_no_hair_fuzzy_wuzzy_wasnt_fuzzy_w
as_he", 4)
In [8]:

nodes
Out[8]:

{'_a_',
'_be',
'_fu',
'_ha',
'_he',
'_no',
'_wa',
'_wu',
'a_b',
'ad_',
'air',
'ar_',
'as_',
'asn',
'bea',
'd_n',
'ear',
'fuz',
'had',
'hai',
'ir_',
'no_',
'nt_',
'o_h',
'r_f',
's_a',
's_h',
'snt',
't_f',
'uzz',
'was',
'wuz',
'y_h',
'y_w',
'zy_',
'zzy'}

In [9]:

edges
Out[9]:

[('fuz', 'uzz'),
('uzz', 'zzy'),
('zzy', 'zy_'),
('zy_', 'y_w'),
('y_w', '_wu'),
('_wu', 'wuz'),
('wuz', 'uzz'),
('uzz', 'zzy'),
('zzy', 'zy_'),
('zy_', 'y_w'),
('y_w', '_wa'),
('_wa', 'was'),
('was', 'as_'),
('as_', 's_a'),
('s_a', '_a_'),
('_a_', 'a_b'),
('a_b', '_be'),
('_be', 'bea'),
('bea', 'ear'),
('ear', 'ar_'),
('ar_', 'r_f'),
('r_f', '_fu'),
('_fu', 'fuz'),
('fuz', 'uzz'),
('uzz', 'zzy'),
('zzy', 'zy_'),
('zy_', 'y_w'),
('y_w', '_wu'),
('_wu', 'wuz'),
('wuz', 'uzz'),
('uzz', 'zzy'),
('zzy', 'zy_'),
('zy_', 'y_h'),
('y_h', '_ha'),
('_ha', 'had'),
('had', 'ad_'),
('ad_', 'd_n'),
('d_n', '_no'),
('_no', 'no_'),
('no_', 'o_h'),

('o_h', '_ha'),
('_ha', 'hai'),
('hai', 'air'),
('air', 'ir_'),
('ir_', 'r_f'),
('r_f', '_fu'),
('_fu', 'fuz'),
('fuz', 'uzz'),
('uzz', 'zzy'),
('zzy', 'zy_'),
('zy_', 'y_w'),
('y_w', '_wu'),
('_wu', 'wuz'),
('wuz', 'uzz'),
('uzz', 'zzy'),
('zzy', 'zy_'),
('zy_', 'y_w'),
('y_w', '_wa'),
('_wa', 'was'),
('was', 'asn'),
('asn', 'snt'),
('snt', 'nt_'),
('nt_', 't_f'),
('t_f', '_fu'),
('_fu', 'fuz'),
('fuz', 'uzz'),
('uzz', 'zzy'),
('zzy', 'zy_'),
('zy_', 'y_w'),
('y_w', '_wa'),
('_wa', 'was'),
('was', 'as_'),
('as_', 's_h'),
('s_h', '_he')]
In [10]:

%dotstr visualize_de_bruijn(nodes, edges)
ir_ r_f uzz zzy nt_ t_f snt ear ar_ _fu bea _ha hai had air y_w _wa _wu a_b _be ad_ s_a _a_ asn fuz zy_ wuz
_no no_ o_h y_h was _he d_n as_ s_h
Again, can you trace the path through the graph?

B. Graph a DNA sequence
Let's graph a very short DNA sequence.
In [11]:

nodes, edges = de_bruijn_ize("ACGCGTCG", 3)
In [12]:

nodes
Out[12]:

{'AC', 'CG', 'GC', 'GT', 'TC'}
In [13]:

edges
Out[13]:

[('AC', 'CG'),
('CG', 'GC'),
('GC', 'CG'),
('CG', 'GT'),
('GT', 'TC'),
('TC', 'CG')]
In [14]:

%dotstr visualize_de_bruijn(nodes, edges)
CG GT GC TC AC
If you didn't know the starting sequence, could you have reconstructed it from the graph? How many
sequences can this graph generate?

C. Graph a polymorphic DNA sequence
Genome sequencing data are not always derived from an inbred or haploid individual and therefore
typically contain polymorphisms. Furthermore, sequencing errors can introduce variants. Let's look at an
example.
In [15]:

#generate 2 sequences that differ by a single mutation at the 7th position
#

G|T

nodes_1, edges_1 = de_bruijn_ize("GCACGCGTCGATATCT", 5);
nodes_2, edges_2 = de_bruijn_ize("GCACGCTTCGATATCT", 5);

#generate a 3rd sequence that has a different ending sequence
#
nodes_3, edges_3 = de_bruijn_ize("GCACGCTTCGATGC", 5);
In [34]:

#combine the nodes and edges from multiple sequences
nd = nodes_1.union(nodes_2)
nd = nd.union(nodes_3)
eg = edges_1 + edges_2[2:7] + edges_3[8:] #Manually combine unique edges
In [35]:

%dotstr visualize_de_bruijn(nd, eg)
CGCT GCTT GTCG TCGA TTCG GCAC CACG CGAT GATA GATG CTTC ATGC ATAT ACGC CGCG GCGT CGTC
ATCT TATC
Adding the 3 different sequences to the DeBruijn graph analysis resulted in two common types of features
that we will encount when making assemblies of a genome or trascriptome.
1. bubbles
•

polymorphisms

•

repetative sequences

•

paralogous sequences

2. tip/tail
•
In [ ]:

read errors

